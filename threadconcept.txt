Benefits of  multi threading :

1)Better Resource Utilization:
 e.g. 
Imagine an application that reads and processes files from the local file system. 
Lets say that reading af file from disk takes 5 seconds and processing it takes 2 seconds.
Processing two files then takes

  5 seconds reading file A
  2 seconds processing file A
  5 seconds reading file B
  2 seconds processing file B
-----------------------
 14 seconds total

By changing the order of the operations, the CPU could be better utilized. Look at this ordering:

  5 seconds reading file A
  5 seconds reading file B + 2 seconds processing file A
  2 seconds processing file B
-----------------------
 12 seconds total
The CPU waits for the first file to be read. 
Then it starts the read of the second file. 
While the second file is being read, the CPU processes the first file.
Remember, while waiting for the file to be read from disk, the CPU is mostly idle.
------------------------------------------------------------------------------------------------
2) Concept of worker thread :
--------------------------------- 
while(server is active){
    listen for request
    hand request to worker thread
  }
--------------------------------
Costs : Context switching overhead
Costs are more than single threading.
----------------------------------------------------
3)Parallel Delegator-worker model:
Stateless worker
one delegator to other workers.
Shared state of memory or shared database.
Ordering is non-deterministic.
4)Assembly line model
5)Functional Parallelism (Event driven model functions as agents) 
6)Same thraeded system :
sharding the database 
single n threaded system per n threaded core.
Thread communication trough messaging(byte sequence).
------------------------------------------------------
Critical Section:
A critical section is a section of code that is executed by multiple threads and 
where the sequence of execution for the threads makes a difference in the result of 
the concurrent execution of the critical section.
--------------------------------------------------------
Race Condition:
When the result of multiple threads executing a critical section may differ depending on the sequence in 
which the threads execute, the critical section is said to contain a race condition.

Why Race Condition Occurs:
The problems arise when multiple threads access the same resources.
For instance the same memory (variables, arrays, or objects), systems (databases, web services etc.) or files.
In fact, problems only arise if one or more of the threads write to these resources.
It is safe to let multiple threads read the same resources, as long as the resources do not change.
-----------------------------------------------------------
Preventing race condition :
Race conditions can be avoided by proper thread synchronization in critical sections.
Thread synchronization can be achieved using a synchronized block of Java code.
Thread synchronization can also be achieved using other synchronization constructs 
like locks or atomic variables like java.util.concurrent.atomic.AtomicInteger.
-----------------------------------------------------------
classic example of race condition :
Singleton getInstance():

public Singleton getInstance(){
if(_instance == null){   //race condition if two threads sees _instance= null
_instance = new Singleton();
}
}
If you call getInstance() method from two thread simultaneously 
its possible that while one thread is initializing singleton after null check,
another thread sees value of _instance reference variable as null especially if your object takes longer time to 
initialize and enters into critical section which eventually results in getInstance() 
returning two separate instance of Singleton. 
------------------------------------------------------------
Thread Safety and shared Resources:

1)Local Variables:
Local variables are stored in each thread's own stack. That means that local variables are never shared between threads.
That also means that all local primitive variables are thread safe.

2)LocalobjectReferences :
They are stored in heap but are thread safe when they are not used by other threads.
If an object created locally never escapes the method it was created in, it is thread safe.
In fact you can also pass it on to other methods and objects as long as none of 
these methods or objects make the passed object available to other threads.

3)Object Member variables :
Object member variables (fields) are stored on the heap along with the object.
Therefore, if two threads call a method on the same object instance and 
this method updates object member variables, the method is not thread safe.  
Either create new object instances or use synchronized blocks or constructs to use that resuource.
--------------------------------------------------------------
To make the code  thread safe we can use following approaches :
1)Create new instances for every thraed.(not good)
2)Make shared instances immutable (as per code reqirement use is strictly prohibited)
e.g.
public class ImmutableValue{

  private int value = 0;

  public ImmutableValue(int value){
    this.value = value;
  }

  public int getValue(){
    return this.value;
  }

  
      public ImmutableValue add(int valueToAdd){
      return new ImmutableValue(this.value + valueToAdd);
      }
  
}
It has been told that immutable objects are thread safe.But we need to write the code to make it thread safe.
e.g. 
public class String {
    private final char value[];
    /** Cache the hash code for the string */
    private int hash; // Default to 0
    public String(char[] value) {
        this.value = Arrays.copyOf(value, value.length);
    }
    public int hashCode() {
        int h = hash;
        if (h == 0 && value.length > 0) {
            char val[] = value;
            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
}
As you can see above code is thread safe since we are not accessing hash variable directly.
If we access the hash variable directly than this code will not be thread safe i.e.
 public int hashCode() {
        if (hash == 0 && value.length > 0) {
            char val[] = value;
            for (int i = 0; i < value.length; i++) {
                hash = 31 * hash + val[i];
            }
        }
        return hash;
    } 
3)Make shared code synchronized. Single point of execution.
--------------------------------------------------------------
Memory Model:
1)Thread Stack
Local variables
Methods
object references at method level.
Cant be shared among threads they have to have a separate copy for shared objects also.
2)Heap:
Objects,Static,Member variables.
Can be shared 
Java Memory Model-->computer Architecture model(RAM)
 